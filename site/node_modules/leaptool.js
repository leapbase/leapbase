'use strict';
var debug = require('debug')('leaptool');
var util = require('util');
var fs = require('fs');
var path = require('path');
var crypto = require('crypto');
var exec = require('child_process').exec;
var moment = require('moment');
var jwt = require('jsonwebtoken');
var _ = require('lodash');

// default setting
exports.getDefaultSetting = function(serverPath) {
  serverPath = path.resolve(serverPath);
  var setting = {
    // web app
    app_name: process.env.LEAPEASE_APP_NAME || 'leapbase',
    website: process.env.LEAPEASE_WEBSITE || 'http://localhost:8050',
    access_check: process.env.LEAPEASE_ACCESS_CHECK || false,
    access_code: process.env.LEAPEASE_ACCESS_CODE || 'password',
    invite_code_user: process.env.LEAPEASE_INVITE_CODE_USER || 'hello',
    invite_code_admin: process.env.LEAPEASE_INVITE_CODE_ADMIN || 'world',
    token_secret: process.env.LEAPEASE_TOKEN_SECRET || 'password1234',
    session_secret: process.env.LEAPEASE_SESSION_SECRET || 'mykey98765',
    // http/https mode
    http_mode: process.env.LEAPEASE_HTTP_MODE || true,
    http_port: process.env.LEAPEASE_HTTP_PORT || 8050,
    https_mode: process.env.LEAPEASE_HTTPS_MODE || false,
    https_port: process.env.LEAPEASE_HTTPS_PORT || 443,
    https_key: process.env.LEAPEASE_HTTPS_KEY || '',
    https_certificate: process.env.LEAPEASE_HTTPS_CERTIFICATE || '',
    https_root_certificate: process.env.LEAPEASE_HTTPS_ROOT_CERTIFICATE || '',
    https_intermediate_certificate: process.env.LEAPEASE_INTERMEDIATE_CERTIFICATE || '',
    http_to_https: process.env.LEAPEASE_HTTP_TO_HTTPS || false, // redirect http to https
    // path name
    app_modules_name: process.env.LEAPEASE_APP_MODULES || 'app_modules',
    public_name: process.env.LEAPEASE_PUBLIC_NAME || 'public',
    server_path: serverPath, // absolute path to site folder
    www_path: path.join(serverPath, 'public'), // absolute path to public folder
    // database
    database: {
      type: process.env.LEAPEASE_DATABASE_TYPE || '', // mongo
      host: process.env.LEAPEASE_DATABASE_HOST || '', // localhost
      port: process.env.LEAPEASE_DATABASE_PORT || '', // 27017
      name: process.env.LEAPEASE_DATABASE_NAME || 'leapbase'
    },
    // socketio
    use_socketio: process.env.LEAPEASE_USE_SOCKET_IO || false,
    // email setting
    email: {
      service: process.env.LEAPEASE_EMAIL_SERVICE || 'gmail',
      username: process.env.LEAPEASE_EMAIL_USERNAME || 'test@example.com',
      password: process.env.LEAPEASE_EMAIL_PASSWORD || 'test',
      sender: process.env.LEAPEASE_EMAIL_SENDER || 'test@example.com'
    },
    analytics: {
      type: process.env.LEAPEASE_ANALYTICS_TYPE || '',
      key: process.env.LEAPEASE_ANALYTICS_KEY || ''
    },
    comming_soon: {
      enabled: false,
      page: 'coming_soon'
    }
  };
  return setting;
};

// create an object with given prototype object
// source: Douglas Crockford - Advanced JavaScript video
exports.object = function(prototypeObject) {
  function F() {};
  F.prototype = prototypeObject;
  var newObject = new F();
  newObject._super = prototypeObject;
  return newObject;
};

// shallow copy of object
exports.cloneObject = function(item) {
  var result = {};
  for (var property in item) {
    result[property] = item[property];
  }
  return result;
}

exports.encrypt = function(text, key) {
  var cipher = crypto.createCipher('aes-256-cbc', key);
  var crypted = cipher.update(text,'utf8','hex');
  crypted += cipher.final('hex');
  return crypted;
};

exports.decrypt = function(input, key) {
  var decipher = crypto.createDecipher('aes-256-cbc', key)
  var dec = decipher.update(input,'hex','utf8')
  dec += decipher.final('utf8')
  return dec;
};

exports.hash = function(input, type) {
  input = input || '';
  type = type || 'sha512';
  return crypto.createHash(type).update(input).digest('hex');
};

exports.pad = function(number, length) {
  var str = '' + number;
  while (str.length < length) {
    str = '0' + str;
  }
  return str;
};

/**
 * force value conversion in given data type, used in getReqParameter
 */
exports.forceDataType = function(object, property, datatype) {
  if (typeof object[property] != 'undefined') {
    switch (datatype) {
      case 'int':
        object[property] = parseInt(object[property]);
        break;
      case 'float':
        object[property] = parseFloat(object[property]);
        break;
      case 'boolean':
        object[property] = !!object[property];
        break;
      default:
        object[property] = object[property] || null;
    }
  }
};

/**
 * collect parameter from req.params, req.body and req.query
 * req.params - route params like /user/:objectId
 * req.body - post request params via connect.bodyDecoder
 * req.query - query string like ?name=joe
 */
exports.getReqParameter = function(req) {
  var parameter = {};
  if (req.params) {
    for (var p in req.params) {
      parameter[p] = req.params[p];
    }
  }
  if (req.body) {
    for (var p in req.body) {
      parameter[p] = req.body[p];
    }
  }
  if (req.query) {
    for (var p in req.query) {
      parameter[p] = req.query[p];
    }
  }
  if (req.files) {
    for (var p in req.files) {
      parameter[p] = req.files[p];
    }
  }

  // enforce data type on certain parameters
  exports.forceDataType(parameter, 'skip', 'int');
  exports.forceDataType(parameter, 'limit', 'int');
  exports.forceDataType(parameter, 'start', 'int');
  exports.forceDataType(parameter, 'end', 'int');

  return parameter;
};

/**
 * set parameters on req.query object
 *
 */
exports.setReqParameter = function(req, parameter) {
  for (var p in parameter) {
    req.query[p] = parameter[p];
  }
};

/**
 * clear parameters on req
 */
exports.clearReqParameter = function(req) {
  req.params = {};
  req.body = {};
  req.query = {};
};

exports.getQueryCondition = function(parameter) {
    var result = {};
    for (var property in parameter) {
      if (property == 'start' ||
          property == 'skip' ||
          property == 'limit' ||
          property == 'sort') {
        // skip property names used in filter
      }  else {
        result[property] = parameter[property];
      }
    }
    debug('getQueryCondition:', result);
    return result;
};

exports.getQueryFilter = function(parameter) {
    var result = {};
    // begin and end are used in pair, converted to skip and limit
    var begin = parseInt(parameter.start) || 0;
    var end = parseInt(parameter.end) || 0;
    if (begin && end) {
        result['skip'] = begin - 1;
        result['limit'] = end - begin + 1;
    }
    // convert start/begin/end to skip/limit for range selection
    if ('start' in parameter) result['skip'] = parameter['start'];
    if ('skip' in parameter) result['skip'] = parameter['skip'];
    if ('limit' in parameter) result['limit'] = parameter['limit'];
    if ('sort' in parameter) result['sort'] = parameter['sort'];
    debug('getQueryFilter:', result);
    return result;
};

exports.getDatabaseSearchCondition = function(module, searchTerm) {
  var result = {};
  var searchFields = module.option && module.option.search_fields || [];
  var fieldConditions = [];
  if (searchTerm && searchFields.length > 0) {
    for (var i = 0; i < searchFields.length; i++) {
      var fieldName = searchFields[i];
      var fieldCondition = {};
      fieldCondition[fieldName] = RegExp(`${searchTerm}`, 'i');
      fieldConditions.push(fieldCondition);
    }
    result = { $or:fieldConditions };
  }
  return result;
};

exports.base64 = {
  // encode JSON object in base64
  encodeObject: function(object) {
    return new Buffer(JSON.stringify(object)).toString('base64');
  },
  encode: function(data) {
    return new Buffer(data).toString('base64');
  },
  // decode JSON object from base64
  decodeObject: function(text) {
    return JSON.parse(new Buffer(text, 'base64').toString());
  },
  decode: function(text) {
    return new Buffer(text, 'base64').toString();
  }
};

exports.stringify = function(input, replacer, spaces, padding) {
  var result = JSON.stringify(input, replacer, spaces);
  var lines = result.split('\n');
  lines = exports.padLines(lines, padding);
  return lines.join('\n');
}

/**
 * jwt token utillity
 */
exports.encodeToken = function(entry, secret) {
  var token = jwt.sign(entry, secret);  // sync operation
  return token;
}

exports.decodeToken = function(token, secret) {
  var decoded = jwt.verify(token, secret);  // sync operation
  return decoded;
}

/**
 * extrac module name from url
 * /data/<module>/xyz
 * /<module>/xyz
 * /data/admin/module/<module>/xyz
 */
exports.getModuleFromUrl = function(url) {
  var module_name = '';
  var parts = url.split('/');
  if (url.match(/^\/data\/admin\/module/)) {
    module_name = parts[4];
  } else {
    if (parts[1] == 'data') {
      module_name = parts[2];
    } else {
      module_name = parts[1];
    }
  }
  return module_name;
}

exports.getMinimumReqRes = function(username) {
  username = username || 'admin';
  var req = { session:{ user:{ username:username } } };
  var res = {};
  return { req, res };
};

exports.getCurrentUser = function(req) {
  req = req || exports.getMinimumReqRes().req;
  return req && req.session && req.session.user || null;
};

exports.getCurrentUsername = function(req) {
  var user = exports.getCurrentUser(req);
  return user && user.username || '';
};

exports.toArray = function(input) {
  var result = input.split(',');
  return result;
};

/*
CText format example:

title: 春思
author: 李白

燕草如碧絲，秦桑低綠枝。
當君懷歸日，是妾斷腸時。
春風不相識，何事入羅幃

Json data
{
	"author": "李白",
	"title": "春思",
	"content": "燕草如碧絲，秦桑低綠枝。\n當君懷歸日， 是妾斷腸時。 \n春風不相識， 何事入羅幃"
}
*/
exports.parseCTextToJson = function(input) {
  var parseResult = {};
  var contentLines = [];
  var inBodySection = false;
  var lineRegex = /^\s?([\w\s]+):\s?(.+)$/;

  var lines = input.split('\n');
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    var isBlankLine = (line.length == 0);
    if (!isBlankLine && !inBodySection) {
      var result = line.match(lineRegex);
      if (result) {
        parseResult[result[1]] = result[2].trim();
      } else {
        inBodySection = true;
      }
    }
    if (inBodySection) {
      contentLines.push(line);
    }
  }
  if (contentLines.length > 0) {
    parseResult.content = contentLines.join('\n');
  }
  return parseResult;
}

exports.toCTextFromJson = function(item, model) {
  var lines = [];
  for (var fieldName in model) {
    var field = model[fieldName];
    var isAutoField = field.config && field.config.auto || false;
    // collect fields in the header section
    if (!isAutoField && fieldName !== 'content') {
      if (item[fieldName]) {
        lines.push(fieldName + ': ' + item[fieldName]);
      }
    }
  }
  // add blank line between header section and body section
  if (lines.length > 0) {
    lines.push('');
  }
  // content is the body section
  if (model.content && item['content']) {
    lines.push(item['content']);
  }
  return lines.join('\n');
};

exports.toHtml = function(input) {
  var result = '';
  if (input) {
    var lines = input && input.split('\n');
    for (var i = 0; i < lines.length; i++) {
      lines[i] = `<p>${lines[i]}</p>`;
    }
    result = '<div>' + lines.join('') + '</div>';
  }
  return result;
}

// model item input example: { title: 'string', content: 'text' }
exports.toModelObject = function(input) {
  var model = {};
  var fieldTypes = [
    'string', 'text', 'number', 'boolean', 'date', 'datetime',
    'file', 'object', 'array'
  ];
  for (var property in input) {
    var propertyValue = input[property].toLowerCase();
    if (fieldTypes.indexOf(propertyValue) >= 0) {
      model[property] = { type:propertyValue };
    }
  }
  return model;
}

exports.toObjectbyModel = function(input, model, app, req) {
  var doc = {};
  req = req || exports.getMinimumReqRes.req;
  for (var property in model) {
    // set default value if model property has default_value
    if (!input.hasOwnProperty(property) && model[property].hasOwnProperty('default_value')) {
      doc[property] = model[property]['default_value'];
    }
    // set create_date and create_by fields if empty
    if (property === 'create_date' && !input[property]) {
      doc[property] = new Date();
    }
    if (property === 'create_by' && !input[property]) {
      doc[property] = exports.getCurrentUsername(req);
    }
    if (input.hasOwnProperty(property)) {
      var value = input[property];
      if (app && app.engine) {
        value = app.engine.castData(input[property], model[property]);
      }
      doc[property] = value;
    }
  }
  return doc;
}

exports.getDefaultReqRes = function() {
  return {
    req: { session:{ user:{ username:'admin' } } },
    res: {}
  }
}

exports.getDefaultModelFields = function() {
  return {
    create_by: { type: 'string', config:{ auto:true } },
    create_date: { type: 'date', config:{ auto:true } },
    edit_by: { type: 'string', config:{ auto:true } },
    edit_date: { type: 'date', config:{ auto:true } }
  };
}

exports.loadDynamicModule = function(app, cmsModel) {
  var moduleName = 'cms_' + cmsModel.name;
  var cmsBase = require(path.join(
    app.setting.server_path,
    app.setting.app_modules_name,
    'cms_base'
  ))(app, moduleName, cmsModel.model);
  // add dynamic appp module if it is not present in app.module
  if (!app.module[moduleName]) {
    debug('load dynamic module:', moduleName);
    app.module[moduleName] = cmsBase;
  }
}

// clojure-20180914.txt, category is clojure, date is 20180914
exports.getCategoryDateFromFilename = function(filename) {
  filename = path.basename(filename);
  var matchResult = filename.match(/^(.+)?[-_](\d{4})(\d{2})(\d{2})\.\w+$/);
  var categoryText = '';
  var filedateText = '';
  if (matchResult) {
    categoryText = matchResult[1] || '';
    filedateText = [matchResult[2], matchResult[3], matchResult[4]].join('-');
  }
  var result = {
    category: categoryText,
    filedate: filedateText
  };
  return result;
}

// get app object for offline use
exports.getAppExt = function(appSitePath) {
  var app = {};
  app.module = [];
  app.server = { get:function(){}, post:function(){}, all:function(){} };
  app.eventEmitter = { on:function(){}, emit:function(){} };
  app.setting = exports.getDefaultSetting(appSitePath);
  var siteSetting = require(path.join(appSitePath, '/setting')).setting;
  app.setting = _.extend(app.setting, siteSetting);
  app.engine = require('web_engine')(app);
  return app;
}

// get app object for offline use, with app.db
exports.getAppExtWithDb = function(appSitePath, callback) {
  var app = exports.getAppExt(appSitePath);
  var Database = require(path.join(
    app.setting.server_path, 'node_modules', 
    app.setting.database.type + '_db.js'));
  app.db = new Database(app, function() {
    callback && callback(app);
  });
}

exports.getAppExtModule = function(app, moduleName) {
  var module = require(path.join(app.setting.server_path, '/app_modules/' + moduleName))(app);
  app.module[moduleName] = module;
  return module;
}

/**
 * Return a random int, used by `getUid()`.
 *
 * @param {Number} min
 * @param {Number} max
 * @return {Number}
 */
exports.getRandomInt = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Return a unique identifier with the given `len`.
 *
 * @param {Number} length
 * @return {String}
 */
exports.getUid = function(length) {
  let uid = '';
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  const charsLength = chars.length;

  for (let i = 0; i < length; ++i) {
    uid += chars[exports.getRandomInt(0, charsLength - 1)];
  }
  return uid;
};


